package main.pkg;

import java.io.FileInputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Scanner;

public class MV {

	static int cuad_actual; //Cuadruplo a ejecutarse
	/**
	 * Espacios de memoria para los diferentes tipos de variables
	 */
	static HashMap<Integer, Double> num_mem_global = 
			new HashMap<Integer, Double>();		//  1000  ...  3000
	static HashMap<Integer, Double> num_mem_local = 
			new HashMap<Integer, Double>();		//  3001  ...  7000
	static HashMap<Integer, Double> num_mem_constante = 
			new HashMap<Integer, Double>();		//  7001  ...  9000
	static HashMap<String, HashMap<Integer, Double>> num_mem;
	
	static HashMap<Integer, Integer> bool_mem_global = 
			new HashMap<Integer, Integer>();	//  9001  ... 10001
	static HashMap<Integer, Integer> bool_mem_local = 
			new HashMap<Integer, Integer>();	// 10001  ... 11000
	static HashMap<Integer, Integer> bool_mem_constante = 
			new HashMap<Integer, Integer>();	// 11001  ... 12000
	static HashMap<String, HashMap<Integer, Integer>> bool_mem;
	
	static String[] arr_cuadruplos;
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		String dirCuads;
		String[] cuadruplos = null;
		init();
		dirCuads = "cuacks.cuads";
		try  
		{
			cuadruplos = read(dirCuads);
		    
		}
		catch (Exception e)
		{
		    System.err.println("Error: " + e.getMessage());
		}
		if(cuadruplos == null) System.exit(-1);
		consumeCuadruplos(cuadruplos);

	}
	
	/**
	 * Se iran resolviendo los diferentes cuadruplos ya generados
	 */
	private static void consumeCuadruplos(String[] cuads) {
		// TODO Auto-generated method stub
		String[] cuadruplos = cuads;
		String[] aux;
		arr_cuadruplos = new String[cuadruplos.length];
		for(int i = 0; i < cuadruplos.length; i++){
			aux = cuadruplos[i].split(":");
			arr_cuadruplos[i] = aux[1];
		}

		generaAccion(arr_cuadruplos[0]);
	}
	
	/**
	 * Se separa el cuadruplo en un arreglo para manejarlo
	 * 
	 * @param cuad
	 * @return str
	 */
	private static String[] separaCuadruplo(String cuad) {
		String[] str;
		str = cuad.split(",");	
		return str;
	}
	
	/**
	 * Realiza la accion de cuadruplo encontrado
	 * @param cuad_i
	 * @param cuad_s
	 */
	private static void generaAccion(String cuadruplo) {
		// TODO Auto-generated method stub
		//log(cuadruplo);
		String [] cuad_s = separaCuadruplo(cuadruplo);
		int[] cuad_i = convierteCuadruplo(cuad_s);
		double oper1;
		double oper2;
		double aux;
		double resultado;
		
		int ope = cuad_i[0];
		int op1 = cuad_i[1];
		int op2 = cuad_i[2];
		int avail_i = cuad_i[3];
		//log(ope + ", " + op1 + ", " + op2 + ", " + avail_i );
		
		String op1_s = cuad_s[1];
		String op2_s = cuad_s[2];
		String avail_s = cuad_s[3];
		//log(ope + ", " + op1_s + ", " + op2_s + ", " + avail_s );

		cuad_actual++;

		switch(ope) {

		case 0:
			//Suma
			oper1 = consigueValorMemoria(op1);
			oper2 = consigueValorMemoria(op2);
			resultado = oper1 + oper2;
			asignaValor(avail_i, resultado);
			aux = consigueValorMemoria(avail_i);
			//log("+"+aux);
			break;
		case 1:
			//Resta
			oper1 = consigueValorMemoria(op1);
			oper2 = consigueValorMemoria(op2);
			resultado = oper1 - oper2;
			asignaValor(avail_i, resultado);
			break;
		case 2:
			//Multiplicacion
			oper1 = consigueValorMemoria(op1);
			oper2 = consigueValorMemoria(op2);
			resultado = oper1 * oper2;
			asignaValor(avail_i, resultado);
			break;
		case 3:
			//Division
			oper1 = consigueValorMemoria(op1);
			oper2 = consigueValorMemoria(op2);
			resultado = oper1 / oper2;
			asignaValor(avail_i, resultado);
			break;
		case 4:
			//Asignacion
			oper1 = consigueValorMemoria(op1);
			asignaValor(avail_i, oper1);
			aux = consigueValorMemoria(avail_i);
			log(avail_i + ": " + aux);
			break;
		case 5:
			//Menor que
			break;
		case 6:
			//Mayor que
			break;
		case 7:
			//Menor que o igual
			break;
		case 8:
			//Mayor que o igual
			break;
		case 9:
			//Diferente
			break;
		case 10:
			//Comparacion
			break;
		case 11:
			//Abre Parentesis
			break;
		case 12:
			//Cierra Parentesis
			break;
		case 13:
			//GoTo
			log("Goto " + avail_i);
			cuad_actual = avail_i - 1;
			break;
		case 14:
			//GoToV
			break;
		case 15:
			//GoToF
			//log ("if: " + op1);
			oper1 = consigueValorMemoria(op1);
			if(oper1 == 0) cuad_actual = avail_i - 1;
			
			
			break;
		case 16:
			//Era
			break;
		case 17:
			//GoSub
			break;
		case 18:
			//Ret
			break;
		case 19:
			//Param
			break;
		case 20:
			break;
		case 21:
			break;
		case 22:
			break;
		case 23:
			break;	
		case 99:
			log("Fin de la ejecucion, champ!");
			System.exit(0);
			break;
		}	
		generaAccion(arr_cuadruplos[cuad_actual]);
	}
	
	/**
	 * Va a la memoria a buscar un valor
	 * @param op1
	 * @return valor
	 */
	private static double consigueValorMemoria(int direccion) {
		// TODO Auto-generated method stub
		int dir = direccion;
		double valor = -1;
		String valor_s = "";
		
		if(dir >= 1000 && dir <= 3000) {
			//num global
			valor = num_mem_global.get(dir);
		} else if ( dir >= 3001 && dir <= 7000) {
			//num local
			valor = num_mem_local.get(dir);
		} else if ( dir >= 7001 && dir <= 9000) {
			//num constante
			valor = num_mem_constante.get(dir);
		} else if (dir >= 9001 && dir <= 10000) {
			//bool global
			valor = bool_mem_global.get(dir);
		} else if (dir >= 10001 && dir <= 11000) {
			//bool local
			valor = bool_mem_global.get(dir);
		} else if (dir >= 11001 && dir <= 12000) {
			//bool constante
//			valor_s = bool_mem_global.get(dir);
			valor = bool_mem_global.get(dir);
		}
		
		return valor;
	}
	
	/**
	 * Convierte cuadruplo de String a un arreglo de enteros
	 * @param cuadruplo
	 * @return
	 */
	private static int[] convierteCuadruplo(String[] cuadruplo) {
		// TODO Auto-generated method stub
		int[] aux = new int [4]; 
		for (int i = 0; i < cuadruplo.length; i++) {
			cuadruplo[i] = cuadruplo[i].replaceAll(" ", "");
			//log("Cuad: " + cuadruplo[i]);
			if(cuadruplo[i].equalsIgnoreCase("") ||
				cuadruplo[i].equalsIgnoreCase(" ")) {
				aux[i] = -1;
			} else if (cuadruplo[i].contains("param"))  {
				aux[i] = 999999;
			} else {
				try {
					aux[i] = Integer.parseInt(cuadruplo[i].trim());
				} catch(NumberFormatException e) {
					aux[i] = 7777777;
				}
			}
		}
		return aux;
	}
	
	/**
	 * Inicializa la memoria de la MV
	 */
	private static  void init() {
		// TODO Auto-generated method stub
	//	num_mem_global.put(10000, 0);
	//	num_mem_local.add((double) 3001);
//		num_mem_constante.add((double) 7001);	
//		bool_mem_global.add(9001);
//		bool_mem_local.add(10001);
//		bool_mem_constante.add(11001);;
//		
		cuad_actual = 0;
		
		num_mem = new HashMap<String, HashMap<Integer, Double>>();
		num_mem.put("mem_local", num_mem_global);
		num_mem.put("mem_global", num_mem_local);
		num_mem.put("mem_constante", num_mem_constante);
		bool_mem = new HashMap<String, HashMap<Integer, Integer>>();
		bool_mem.put("mem_local", bool_mem_global);
		bool_mem.put("mem_global", bool_mem_local);
		bool_mem.put("mem_constante", bool_mem_constante);
		
	}
	
	/** 
	 * Lee el archivo objeto y lo va transformando a sus operaciones
	 * @param str
	 * @throws IOException
	 */
	static String[] read(String str) throws IOException{
		List<String> llines = new ArrayList<String>();
		String[] lines;
		String strr = "";
		boolean salto = true;
	    Scanner scanner = new Scanner(new FileInputStream(str));
		try {
			while (scanner.hasNextLine() && salto){
				int dir;
				double valor;
				strr = scanner.nextLine();
				if(!strr.contains("&&&")) {
					dir = obtenDir(strr);
					valor = obtenValor(strr);
					asignaValor(dir, valor);
				} else salto = false;
			}
			salto = true;
			while (scanner.hasNextLine()){
				strr = scanner.nextLine();
				if(strr.contains("&&&")) {
					salto = false;
				}
				else {
					llines.add(strr);
				}
		    }
			lines = llines.toArray(new String[0]);
			
			
		}finally{
			scanner.close();
		}
		
		/*for(String line : lines) {
			log(line);
		}*/
		
		return lines;
	}
	
	/**
	 * Obtiene el valor de la tabla de Ctes
	 * @param strr
	 * @return valor
	 */
	private static double obtenValor(String strr) {
		// TODO Auto-generated method stub
		String[] aux;
		double valor;
		aux = strr.split(",");
		valor = Double.parseDouble(aux[1]);
		return valor;
	}
	
	/**
	 * Obtiene la dir de la tabla de Ctes
	 * @param strr
	 * @return dir
	 */
	private static int obtenDir(String strr) {
		// TODO Auto-generated method stub
		String[] aux;
		int dir;
		aux = strr.split(",");
		dir = Integer.parseInt(aux[0]);
		return dir;
	}

	/**
	 * A una direccion le da un valor
	 * @param dir
	 * @param valor
	 */
	private static void asignaValor(int dir, double valor) {
		// TODO Auto-generated method stub
		//log("d: " + dir + " v: " + valor);
		if(dir >= 1000 && dir <= 3000) {
			//num global
			num_mem_global.put(dir, valor);
		} else if ( dir >= 3001 && dir <= 7000) {
			//num local
			num_mem_local.put(dir, valor);
		} else if ( dir >= 7001 && dir <= 9000) {
			//num constante
			num_mem_constante.put(dir, valor);
		} else if (dir >= 9001 && dir <= 10000) {
			//bool global
			bool_mem_global.put(dir, (int)valor);
		} else if (dir >= 10001 && dir <= 11000) {
			//bool local
			bool_mem_global.put(dir, (int)valor);
		} else if (dir >= 11001 && dir <= 12000) {
			//bool constante
			bool_mem_global.put(dir, (int)valor);
		}
	}

	/**
	 * Escribe un mensaje a consola
	 * @param aMessage
	 */
	private static void log(String aMessage){
	    System.out.println(aMessage);
	  }

}
